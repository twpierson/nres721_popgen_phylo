---
title: "Basic population genomic analyses"
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
knit: (function(input_file, encoding) {
  out_dir <- 'docs';
  rmarkdown::render(input_file,
 encoding=encoding,
 output_file=file.path(dirname(input_file), out_dir, 'index.html'))})
author: "Todd W. Pierson"
date: "23 October 2019"
---

<style>
pre code, pre, code {
  white-space: pre !important;
  overflow-x: scroll !important;
  word-break: keep-all !important;
  word-wrap: initial !important;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(width=200)
```

<div class="alert alert-danger">
  <strong>Note:</strong> This tutorial is written to teach some basic population genomic analyses for NRES 721. We'll do these exercises entirely in `R`, so folks should be able to follow along regardless of their operating system.
</div>

## Introduction
In the last tutorial, we assembled a RADseq-style (RADcap) dataset from the patch-nosed salamander (*Urspelerpes brucei*) in `ipyrad`. We ended up with a total of 948 loci (and 1131 SNPs) in our de novo assembly and 641 loci (and 753 SNPs) in our reference-based assembly. As you've discussed earlier in the semester, there are a *multitude* of ways in which you can analyze these kinds of population genetic data. Today, we'll apply some of the methods you've already learned and discuss how large datasets—and in 2019, several hundred loci barely qualifies as "large"!—may present unique challenges. Today, we'll work entirely in `R`.

First, let's the packages you need. If you don't already have these installed, do that first.
```{r, echo = TRUE, results = "hide", warning = FALSE, message = FALSE}
library(phangorn)
library(adegenet)
library(hierfstat)
library(scales)
```

## Neighbor-joining tree

For an easy, preliminary visualization of our data, let's build a neighbor-joining tree. This will (very quickly) estimate a topology from a distance matrix, which we'll calculate from our SNP data. There are many good reasons not to ultimately read too much into this topology, but it can provide a good jumping-off point to check our data.

First, we'll read in one of the output files from the `ipyrad` de novo assembly. The file extension `u.snps.phy` tells us that this is a PHYLIP file consisting of one random SNP per locus.

<div class="alert alert-info">
  <strong>Discussion:</strong> Why might we only include one SNP per locus?
</div>

```{r}
ubrucei_phydat <- read.phyDat("data/ubrucei_denovo.u.snps.phy", format="phy", type="DNA")
```

Let's examine this object we've just created.
```{r}
ubrucei_phydat
```

<div class="alert alert-info">
  <strong>Discussion:</strong> This suggests that we have 417 "character site patterns". What does that mean? Why is this number smaller than the number of loci we have?
</div>

From these data, we'll first create a distance matrix.
```{r}
ubrucei_dm <- dist.ml(ubrucei_phydat, exclude="pairwise")
```

From this distance matrix, we'll create a neighbor-joining tree.
```{r}
ubrucei_NJtree <- NJ(ubrucei_dm)
```

And we'll now plot that as an unrooted tree, coloring the tips to match the collection locality of each sample. 
```{r}
plot.phylo(ubrucei_NJtree, cex=0.9, type='u',
     tip.col = c(rep("green",3), rep("red",3), rep("cornflowerblue",3), rep("purple",3)),
     font = 2, x.lim = c(-0.1, 0.4))
```

<div class="alert alert-info">
  <strong>Discussion:</strong> Just examining this visually, what do you notice? Does this serve as a good "sanity check" for our data?
</div>


## DAPC
This neighbor-joining tree provides a hint that our collection localities may be genetically differentiated, but it's a very qualitative evaluation. Next, we'll try a method to estimate how many "populations" or "clusters" actually exist among these data.

There are a variety of programs—with a diversity of underlying philosophies and statistical methods—to conduct this kind of analysis. For example, you used `Structure` in an earlier class. Today, we'll try a [discriminant analysis of principle components (DAPC)](https://bmcgenet.biomedcentral.com/articles/10.1186/1471-2156-11-94_). This method estimates the number of "genetic clusters" in the data and then estimates probabilistic individual assignments to each cluster. For a much more detailed description of these analyses and a tutorial of how to conduct them, see [here](http://adegenet.r-forge.r-project.org/files/tutorial-dapc.pdf).

For this analysis, let's read in a different output file from `ipyrad`. The file extension (`.str`) tells us that this is a Structure-formatted output file, and it contains data for all variable sites. We need to provide the `read.structure()` function a few more pieces of information (e.g., number of individuals, number of loci), which we can glean from the summary statistics file we viewed in the last tutorial.

```{r results = "hide", warning = FALSE, message = FALSE}
ubrucei_strdat <- read.structure(file="data/ubrucei_denovo.str",
                         n.ind = 12, n.loc = 1131,
                         onerowperind = FALSE, col.lab=1,
                         col.pop=0, NA.char="-9",col.other=0,
                         row.marknames=0)
```

The first step of the DAPC is to estimate the number of clusters. We'll use the `find.clusters()` function to do this, and it'll display interactive plots to help use choose the numbers of PCs to retain and the number of clusters.

```{r, eval = FALSE}
set.seed(1234)
ubrucei_clust <- find.clusters(ubrucei_strdat, max.n.clust = 5)
```

<center>![](figs/PC_Plot.jpeg){ width=40% }</center>

This plot shows the cumulative variance explained by including progressively more principal components. It looks like there's really no plateau of cumulative variance, so we can retain all 10 PCs. Enter "10" into the prompt.

<center>![](figs/clust_Plot.jpeg){ width=40% }</center>

This plot helps us evaluate how many "clusters" best represent our data; here, we're looking for when the BIC value is minimized (or stops decreasing dramatically). The BIC value continues to drop through *k* = 4, but then levels off. Go ahead and enter "4" into the prompt.

```{r}
set.seed(1234)
ubrucei_clust <- find.clusters(ubrucei_strdat, n.pca = 10, n.clust = 4)
```

Now, we'll conduct the discriminant analysis. Because we have a small number of PCs and clusters, we'll retain all of them here (i.e., enter "10" for `n.pca` and "3" for `n.da`).
```{r}
set.seed(1234)
ubrucei_dapc <- dapc(ubrucei_strdat, ubrucei_clust$grp, n.pca = 10, n.da = 3)
```

We can glean lots of interesting information from this analysis. Perhaps the most important result for us is in the "posterior group assignments". We can plot these results in a Structure-like barplot.
```{r}
par(xpd = TRUE)
compoplot(ubrucei_dapc, xlab="individuals", 
          col = c("red","cornflowerblue","green","purple"), legend = FALSE,
          show.lab = TRUE)
legend(3.1, 1.1, legend=paste("Cluster", 1:4), fill=c("red","cornflowerblue","green","purple"), ncol = 4, cex = 0.7)
```

<div class="alert alert-info">
  <strong>Discussion:</strong> What do these results suggest to you?
</div>

## Diversity, differention, etc.

This analysis provides some evidence of differentiation between populations of *Urspelerpes* at these different collection localities. But how different are they? And how genetically diverse are they? Note: because we have such small sample sizes here, we should interpret all of these results with caution!

Let's calculate some common summary statistics to characterize genetic diversity within and among these clusters. First, we can calculate pairwise F~st~ between each cluster.

```{r warning = FALSE, comment = NA}
ubrucei_strdat$pop <- as.factor(c(rep(1,3),rep(2,3),rep(3,3),rep(4,3)))

(matFst <- pairwise.fst(ubrucei_strdat,res.type="matrix"))
```

<div class="alert alert-info">
  <strong>Discussion:</strong> Are these results consistent with our visualization in the neighbor-joining tree?
</div>

Now, let's calculate some basic measures of genetic diversity. Let's use the expected (intrapopulation) heterozygosity (i.e., H~s~ or D) and observed heterozygosity (H~o~) to get a glimpse of this. We can use the `basic.stats()` function in the `hierfstat` package.

```{r, fig.height = 3, fig.align = "center", width = 200}
ubrucei_stats <- basic.stats(ubrucei_strdat,diploid=TRUE,digits=3)
```

We can plot H~s~ for each population. 
```{r, fig.height = 3, fig.align = "center", width = 200}
par(mfrow=c(1,4))
hist(ubrucei_stats$Hs[,1], col = "green", main = "site 1", 
     ylab = "# SNPs", xlab = "expected heterozygosity", ylim = c(0,1000))
text(x = 0.6, y = 600, labels = paste("mean =", round(mean(ubrucei_stats$Hs[,1], na.rm = TRUE), 2)))
hist(ubrucei_stats$Hs[,2], col = "red", main = "site 2", 
     ylab = "# SNPs", xlab = "expected heterozygosity", ylim = c(0,1000))
text(x = 0.6, y = 600, labels = paste("mean =", round(mean(ubrucei_stats$Hs[,2], na.rm = TRUE), 2)))
hist(ubrucei_stats$Hs[,3], col = "cornflowerblue", main = "site 3", 
     ylab = "# SNPs", xlab = "expected heterozygosity", ylim = c(0,1000))
text(x = 0.6, y = 600, labels = paste("mean =", round(mean(ubrucei_stats$Hs[,3], na.rm = TRUE), 2)))
hist(ubrucei_stats$Hs[,4], col = "purple", main = "site 4", 
     ylab = "# SNPs", xlab = "expected heterozygosity", ylim = c(0,1000))
text(x = 0.6, y = 600, labels = paste("mean =", round(mean(ubrucei_stats$Hs[,4], na.rm = TRUE), 2)))
```

... and H~o~ for each population.
```{r, fig.height = 3, fig.align = "center", width = 200}
par(mfrow=c(1,4))
hist(ubrucei_stats$Ho[,1], col = "green", main = "site 1", 
     ylab = "# SNPs", xlab = "observed heterozygosity", ylim = c(0,1000))
text(x = 0.6, y = 600, labels = paste("mean =", round(mean(ubrucei_stats$Ho[,1], na.rm = TRUE), 2)))
hist(ubrucei_stats$Ho[,2], col = "red", main = "site 2", 
     ylab = "# SNPs", xlab = "observed heterozygosity", ylim = c(0,1000))
text(x = 0.6, y = 600, labels = paste("mean =", round(mean(ubrucei_stats$Ho[,2], na.rm = TRUE), 2)))
hist(ubrucei_stats$Ho[,3], col = "cornflowerblue", main = "site 3", 
     ylab = "# SNPs", xlab = "observed heterozygosity", ylim = c(0,1000))
text(x = 0.6, y = 600, labels = paste("mean =", round(mean(ubrucei_stats$Ho[,3], na.rm = TRUE), 2)))
hist(ubrucei_stats$Ho[,4], col = "purple", main = "site 4", 
     ylab = "# SNPs", xlab = "observed heterozygosity", ylim = c(0,1000))
text(x = 0.6, y = 600, labels = paste("mean =", round(mean(ubrucei_stats$Ho[,4], na.rm = TRUE), 2)))
```

<div class="alert alert-info">
  <strong>Discussion:</strong> What patterns do you detect here?
</div>

## Isolation-by-distance
We may wonder whether the apparent differention between sampling localities can be explained by geographic distance. We can test for isolation-by-distance using a Mantel test. Because this is a rare, sensitive species, we won't use real coordinates, but I'll (generally) preserve the spatial relationship between sites and center them over [Sanford Stadium (Go Dawgs)](https://goo.gl/maps/9FsrhfEz9wj9ULPU9). Below are our artificial coordinates; note that for all samples within a site, the coordinates are the same.

```{r}
coords <- rbind(c(33.949966,-83.374063), c(33.949966,-83.374063), c(33.949966,-83.374063),
                c(33.944970, -83.373114), c(33.944970, -83.373114), c(33.944970, -83.373114),
                c(33.950171, -83.373929), c(33.950171, -83.373929), c(33.950171, -83.373929),
                c(33.949900, -83.372304), c(33.949900, -83.372304), c(33.949900, -83.372304))
```

Here's a quick visualization of their positions:
```{r, echo = FALSE}
plot(coords[,2],coords[,1], xlim = c(min(coords[,2])-0.0005, max(coords[,2]+0.0005)), 
     ylim = c(min(coords[,1])-0.00025, max(coords[,1]+0.00025)), pch = 19, cex = 2,
     col = c(rep("green",3), rep("red",3), rep("cornflowerblue",3), rep("purple",3)),
     xlab = "longitude", ylab = "latitude")
text(x=coords[c(1,4,7,10),2], y = coords[c(1,4,7,10),1], col = "white", labels = c(1,2,3,4))
```

...here is the actual Mantel test.
```{r}
(mtest <- mantel.randtest(dist(ubrucei_strdat), dist(coords)))
plot(mtest, nclass = 30)
```

<div class="alert alert-info">
  <strong>Discussion:</strong> What do these results mean?
</div>

We can visualize this relationship by plotting geographic distance against genetic distance.
```{r}
plot(dist(coords),dist(ubrucei_strdat), pch = 19, col = alpha("black",0.3),
     xlab = "geographic distance", ylab = "genetic distance")

```

## Optional exercise
Now that we've completed these analyses using our de novo assembly, repeat them using the reference-based assembly.

<div class="alert alert-info">
  <strong>Discussion:</strong> Do these results differ meaningfully?
</div>